#!/usr/bin/env python3
"""
Analyzes and visualizes the convergence of a Wasserstein Barycenter computation
from output files generated by the Lloyd's algorithm iteration.

This script generates three things:
1. An interactive 3D plot with a slider to view the point cloud at each iteration.
2. A static 2D plot showing the convergence metrics over time.
3. A GIF animation showing both XY view and 3D view of the point cloud evolution.
"""

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.widgets import Slider
import glob
import os
import re
from mpl_toolkits.mplot3d import Axes3D
import matplotlib.animation as animation
from matplotlib.gridspec import GridSpec

def load_points_file(filename):
    """Loads a text file containing 3D points."""
    try:
        points = np.loadtxt(filename)
        # Handle case where file has only one point
        if points.ndim == 1:
            points = points.reshape(1, -1)
        return points
    except Exception as e:
        print(f"Warning: Could not load or parse {filename}: {e}")
        return None

def find_and_sort_files(prefix="barycenter"):
    """
    Finds all initial, iteration, and final files for a given prefix.
    Sorts them logically: initial, iter_1, iter_2, ..., final.
    """
    files = []
    
    # 1. Find initial file
    initial_file = f"{prefix}_initial.txt"
    if os.path.exists(initial_file):
        files.append(initial_file)

    # 2. Find iteration files and sort them numerically
    iter_pattern = f"{prefix}_iter_*.txt"
    iter_files = glob.glob(iter_pattern)
    
    def get_iter_num(f):
        match = re.search(r'_iter_(\d+)\.txt', f)
        return int(match.group(1)) if match else -1

    iter_files.sort(key=get_iter_num)
    files.extend(iter_files)
    
    # 3. Find final file
    final_file = f"{prefix}_final.txt"
    if os.path.exists(final_file):
        files.append(final_file)
        
    return files

def create_slider_visualization(iterations, labels):
    """Creates an interactive 3D plot with a slider to scrub through iterations."""
    if not iterations:
        return None, None

    fig = plt.figure(figsize=(10, 8))
    ax = fig.add_subplot(111, projection='3d')
    plt.subplots_adjust(left=0.1, right=0.9, top=0.9, bottom=0.15)

    # Determine global bounds for consistent axis scaling
    all_points = np.vstack(iterations)
    min_bounds = all_points.min(axis=0)
    max_bounds = all_points.max(axis=0)
    
    # Initial plot
    points = iterations[0]
    scatter = ax.scatter(points[:, 0], points[:, 1], points[:, 2], s=10, alpha=0.7)

    # Set equal aspect ratio
    max_range = np.array([max_bounds[0]-min_bounds[0], max_bounds[1]-min_bounds[1], max_bounds[2]-min_bounds[2]]).max() / 2.0
    mid_x = (max_bounds[0]+min_bounds[0]) * 0.5
    mid_y = (max_bounds[1]+min_bounds[1]) * 0.5
    mid_z = (max_bounds[2]+min_bounds[2]) * 0.5
    ax.set_xlim(mid_x - max_range, mid_x + max_range)
    ax.set_ylim(mid_y - max_range, mid_y + max_range)
    ax.set_zlim(mid_z - max_range, mid_z + max_range)
    
    ax.set_xlabel("X")
    ax.set_ylabel("Y")
    ax.set_zlabel("Z")
    title = ax.set_title(f"Barycenter Evolution - {labels[0]}")

    # Create slider axis and the slider itself
    ax_slider = plt.axes([0.2, 0.05, 0.65, 0.03])
    slider = Slider(ax_slider, 'Iteration', 0, len(iterations) - 1, valinit=0, valstep=1)

    def update(val):
        """Function to be called when the slider value changes."""
        idx = int(slider.val)
        new_points = iterations[idx]
        
        # --- EFFICIENT PLOT UPDATE ---
        # This updates the data of the existing plot instead of redrawing everything.
        # It's much faster and avoids flickering.
        scatter._offsets3d = (new_points[:, 0], new_points[:, 1], new_points[:, 2])
        
        title.set_text(f"Barycenter Evolution - {labels[idx]}")
        fig.canvas.draw_idle()

    slider.on_changed(update)
    return fig, slider


def create_convergence_plot(iterations, labels):
    """Creates a static plot showing convergence metrics over iterations."""
    if len(iterations) < 2:
        print("Not enough iterations to create a convergence plot.")
        return None

    # --- ACCURATE CONVERGENCE METRIC ---
    # Calculate the Root Mean Square (RMS) of the movement of each point
    # This is a much better metric than the movement of the global centroid.
    rms_movements = []
    for i in range(1, len(iterations)):
        # Ensure point counts match before calculating difference
        if iterations[i].shape == iterations[i-1].shape:
            diff_sq = np.sum((iterations[i] - iterations[i-1])**2, axis=1)
            rms_movement = np.sqrt(np.mean(diff_sq))
            rms_movements.append(rms_movement)
        else:
            rms_movements.append(np.nan) # Mark as not-a-number if shapes differ

    # Calculate the standard deviation of the point cloud at each step
    spreads = [np.mean(np.std(p, axis=0)) for p in iterations]

    fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(12, 8), sharex=True)
    fig.suptitle("Convergence Analysis", fontsize=16)

    # Plot RMS Point Movement
    ax1.plot(range(1, len(rms_movements) + 1), rms_movements, 'o-', color='red', label="RMS Point Movement")
    ax1.set_ylabel("RMS Point Movement")
    ax1.set_title("Point-wise Convergence")
    ax1.set_yscale('log')
    ax1.grid(True, which="both", linestyle='--', linewidth=0.5)

    # Plot Point Cloud Spread
    ax2.plot(range(len(spreads)), spreads, 's-', color='green', label="Average Std. Dev.")
    ax2.set_xlabel("Iteration")
    ax2.set_ylabel("Point Cloud Spread (Avg. Std)")
    ax2.set_title("Point Cloud Shape Evolution")
    ax2.grid(True, which="both", linestyle='--', linewidth=0.5)

    plt.tight_layout(rect=[0, 0, 1, 0.96])
    return fig

def create_animation_gif(iterations, labels, filename="barycenter_evolution.gif"):
    """Creates a GIF animation with two columns: XY view and 3D view."""
    if not iterations:
        print("No iterations to animate.")
        return
    
    print(f"Creating animation with {len(iterations)} frames...")
    
    # Set LaTeX font for all text
    plt.rcParams['text.usetex'] = True
    plt.rcParams['font.family'] = 'serif'
    plt.rcParams['font.size'] = 12
    
    # Create figure with two subplots side by side
    fig = plt.figure(figsize=(16, 8))
    gs = GridSpec(1, 2, width_ratios=[1, 1])
    
    # Adjust layout to leave space for the title
    plt.subplots_adjust(top=0.85)
    
    # 2D XY view
    ax_2d = fig.add_subplot(gs[0, 0])
    ax_2d.set_xlabel(r"$X$")
    ax_2d.set_ylabel(r"$Y$")
    ax_2d.set_title(r"XY View")
    
    # 3D view
    ax_3d = fig.add_subplot(gs[0, 1], projection='3d')
    ax_3d.set_xlabel(r"$X$")
    ax_3d.set_ylabel(r"$Y$")
    ax_3d.set_zlabel(r"$Z$")
    ax_3d.set_title(r"3D View")
    
    # Determine global bounds for consistent axis scaling
    all_points = np.vstack(iterations)
    min_bounds = all_points.min(axis=0)
    max_bounds = all_points.max(axis=0)
    
    # Set equal aspect ratio for 3D plot
    max_range = np.array([max_bounds[0]-min_bounds[0], max_bounds[1]-min_bounds[1], max_bounds[2]-min_bounds[2]]).max() / 2.0
    mid_x = (max_bounds[0]+min_bounds[0]) * 0.5
    mid_y = (max_bounds[1]+min_bounds[1]) * 0.5
    mid_z = (max_bounds[2]+min_bounds[2]) * 0.5
    
    # Initial plots
    scatter_2d = ax_2d.scatter([], [], s=10, alpha=0.7)
    scatter_3d = ax_3d.scatter([], [], [], s=10, alpha=0.7)
    
    # Add centered text at the top of the figure for iteration number
    # Use suptitle instead of fig.text for better compatibility with animation
    title_text = fig.suptitle("", fontsize=18, y=0.95,
                             bbox=dict(boxstyle="round,pad=0.5", facecolor="white", alpha=0.9))
    
    # Set fixed axis limits
    ax_2d.set_xlim(mid_x - max_range, mid_x + max_range)
    ax_2d.set_ylim(mid_y - max_range, mid_y + max_range)
    ax_2d.set_aspect('equal')
    
    ax_3d.set_xlim(mid_x - max_range, mid_x + max_range)
    ax_3d.set_ylim(mid_y - max_range, mid_y + max_range)
    ax_3d.set_zlim(mid_z - max_range, mid_z + max_range)
    
    def init():
        """Initialize animation."""
        scatter_2d.set_offsets(np.empty((0, 2)))
        scatter_3d._offsets3d = ([], [], [])
        title_text.set_text("")
        return scatter_2d, scatter_3d, title_text
    
    def animate(i):
        """Update animation for frame i."""
        points = iterations[i]
        scatter_2d.set_offsets(points[:, :2])  # XY coordinates only
        scatter_3d._offsets3d = (points[:, 0], points[:, 1], points[:, 2])
        
        # Display iteration number at the top center of the figure
        title_text.set_text(rf"Iteration {i}")
        
        return scatter_2d, scatter_3d, title_text
    
    # Create animation with blitting disabled for better compatibility
    anim = animation.FuncAnimation(
        fig, animate, init_func=init, frames=len(iterations),
        interval=200, blit=False  # Disabled blitting for better text rendering
    )
    
    # Save as GIF with higher FPS
    print(f"Saving animation to {filename}...")
    anim.save(filename, writer='pillow', fps=5, dpi=100)  # Increased FPS from 2 to 5
    plt.close(fig)
    print(f"Animation saved to {filename}")
    
    # Reset matplotlib settings
    plt.rcParams['text.usetex'] = False
    plt.rcParams['font.family'] = 'DejaVu Sans'
    plt.rcParams['font.size'] = 10
    
    return filename

def main():
    """Main function to find files, load data, and generate plots."""
    print("=" * 40)
    print("Wasserstein Barycenter Iteration Visualizer")
    print("=" * 40)
    
    output_prefix = "barycenter" # Change this if your files have a different prefix
    files = find_and_sort_files(output_prefix)

    if not files:
        print(f"Error: No files found with prefix '{output_prefix}'.")
        print("Please check the directory or the 'output_prefix' variable in the script.")
        return

    print(f"Found {len(files)} files to process...")
    iterations = []
    labels = []
    for f in files:
        points = load_points_file(f)
        if points is not None:
            iterations.append(points)
            # Create a clean label from the filename
            label = os.path.basename(f).replace(output_prefix, '').replace('_', ' ').replace('.txt', '').strip().title()
            labels.append(label)
    
    if len(iterations) < 1:
        print("Could not load any valid iteration data.")
        return

    print("\nSuccessfully loaded data. Creating visualizations...")
    
    # Keep the slider object in a variable to prevent it from being garbage collected
    vis_fig, slider_obj = create_slider_visualization(iterations, labels)
    
    # Create the static convergence plot
    conv_fig = create_convergence_plot(iterations, labels)
    
    # Create and save the animation GIF
    gif_file = create_animation_gif(iterations, labels)
    print(f"Animation saved to {gif_file}")

    plt.show()

if __name__ == "__main__":
    main()